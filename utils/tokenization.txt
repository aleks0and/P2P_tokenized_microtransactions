pragma solidity 0.5.11;

contract stmt_tokenizatino{
    
    struct stmt_token{
        // we might not need to story name surname etc. on the token, he're we can store only username == user_id and we can retreive it from our db. 
        // or we can just store everything on the tokens not to keep such info on db. 
        // string name;
        // string surname;
        // string account_number;
        // string email_address;
        bytes username;
        int32 balance;  // balance is how much you owe or are owed.
        int16 currency_type; // we're going to store it on the application config files. ex. EUR - 0, USD - 1, YEN - 2....
        bytes balance_string; // same as above but in objects.
        bool token_string; // indication if the token object is written in string
        bool token_status; // indication if the token is completed or not
        bool token_type; // indication if the token is lendee or lender
        uint date_creation;
        uint date_settled;
    }
    
    // Usually the account_number consits of 30+ alphanumerical digits, hence the string store
    // first two elements of account_number the string are the Country code
    // first four elements of account_number are check country, verification digits
    // Do verification of email_address later
    // we're creating the user structre for the simplicity  of holding the information for 
    
    /*
    struct user{
        bytes name;
        bytes surname;
        bytes account_number;
        bytes username;
        bytes email_address;
    }
    
    
    struct user_account{
        user user_info;
        stmt_token[] token_owned_pending;
    // this is most likely going to be stored in form of db. (not from the side of the contracts)
        stmt_token[] token_owned_settled;
    }
    
    
    
    function parse_user_info(user user_info) public{
        stmt_token memory token = smtm_token({name:user_info.name,
            surname:user_info.surname, account_number:user_info.account_number,
            balance:-1,balance_string:"",username:user_info.username,
            email_address:user_info.email_address,status:-1,token_type:-1,
            date_creation:-1,date_settled:-1});
        return stmt_token
    }
    
    
    function retrieve_user_info(string user_id, bool from_app) public{
        // retrieve user_info from db or from app_info.
        // mocked user for now
        if (from_app){
            user user_info = user({name:"name", surname:"surname", account_number:"account_number", 
                               username:user_id, email_address:"user@email.com"}) 
        }
        else{
            user user_info = user({name:"name", surname:"surname", account_number:"account_number", 
                                   username:user_id, email_address:"user@email.com"}) 
        }
        return user_info
    }
    
    
    function get_user_pending_tokens(user_account account) public{
        uint number_of_tokens = account.token_owned_pending.length
        for (uint i=0; i<=number_of_tokens; i++){
            string exposure_username = account.token_owned_pending[i].username
            if (account.token_owned_pending[i].balance == -1){
                string exposure_balance = account.token_owned_pending[i].balance_string
            }
            else{
                uint exposure_balance = account.token_owned_pending[i].balance
            }
            // todo: how the fuck do you print this?
        }
    }
    */
    
    function update_token_settlement(stmt_token token) private returns(stmt_token){
        token.date_settled = now;
        token.token_status = false;
        return token;
    }
    
    function update_token(bytes _user_id, bool _token_type, bool _token_string) private returns(stmt_token){
        return stmt_token(_user_id, 0, 0, "", _token_string, true, _token_type, now, 0);
    }
    
    stmt_token private __lender;
    stmt_token[] private __lendees;
    
    
    
    constructor(bytes userid_lender,bytes userid_lendee, int32 useridx_lendee,
                int32 balance, bytes balance_string, bool token_string) {
    // logic about barter.
    // if token_string is true it is a barter
        if (token_string){
            __lender = update_token(userid_lender, 0, 1);
            __lender.balance_string = balance_string;
            __lendees[useridx_lendee] = update_token(userid_lendee, 1, 1);
            __lendees[useridx_lendee].balance_string = balance_string;
        }
        else{
            __lender = update_token(userid_lender, 0, 0);
            __lender.balance = balance;
            __lendees[useridx_lendee] = update_token(userid_lendee, 1, 0);
            __lendees[useridx_lendee].balance = balance * -1;
        }
    }
    
  // ideally we get all necessary info from app. 
  // below are the exposure methods we will provide to app back.
  // we will not allow for setter 
  // basic getter 
  // we should write getters for specific fields in the tokens, not tokens as a whole
    function return_token_lender() public {
         return __lender;
    }
    function return_token_lendee() public {
        return __lendees[0];
    }
    
    
  // we're generating as many tokens as there are people in the transaction, with orientation 1 lender multiple lendees.
    // we generate as much tokens as usernames passed, with the specified split.
    // todo floading point operations in solidity
    // we can take the assumption that we multiply incomming transaction values by 100.
    // we sub them by multiplying the value of the transaction by 100. because there is no support for double/floats
    function split_payment(bytes _lender_id, bytes[] _lendee_ids, int32 _balance, bytes _balance_string, bool _even_split, int32[] _split, bool _token_string) public{
        // we're using same name here as we're resolving this in separate cases. 
        if (_even_split){
            // string operations in solidity?
            // idk if this compiles tho
            bytes balance_division = balance_string + ' 1/' + string($_lendee_ids.length + 1);
        }
        else{
            int32 balance_division = balance / (lendee_ids.length + 1);
        }
        if(token_string){
            __lender = update_token(_lender_id, 0, 1);
            __lender.balance = balance ;
        }
        else{
            __lender = update_token(_lender_id, 0, 0);
            __lender.balance = balance ;
        }
        
        for (uint i=0; i<=lendee_ids.length; i++){
            // we're reading lender infos from db
            // structure her is wrong for now. cause here we'd like to create tokens where we shouldn't apply to constructor
            if (even_split){
                if(token_string){
                    // handling of balance as string and number has to be corrected
                    __lendees[i] = update_token(_lendee_ids[i], 1, 1);
                    __lendees[i].balance_string = balance_division;
                }
                else{
                    __lendees[i] = update_token(_lendee_ids[i], 1, 0);
                    __lendees[i].balance = balance_division;
                }
            }
            else{
                if(token_string){
                    __lendees[i] = update_token(_lendee_ids[i], 1, 1);
                    __lendees[i].balance_string = string(balance_division + ' ' + _split[i] + '/100');
                }
                else{
                    __lendees[i] = update_token(_lendee_ids[i], 1, 0);
                    __lendees[i].balance = balance * 100 / _split[i];
                }
            }
        }
    }
    
    function token_transfer(bytes transfer_origin, bytes transfer_destination, bytes accepting_party, stmt_token token_origin, stmt_token token_accepting) public
    {
        // we create token between accepting_party and transfer_destination with the balance from the original token.
        int amount_transefered_int = token_accepting.balance;
        int amount_transefered_string = token_accepting.balance_string;
        settle_contract(token_origin, token_accepting);
        if (token_origin.token_type){
            // this means origin owed 
            __lender = token_accepting;
            __lender.username = accepting_party;
            __lender.token_status = true;
            __lendees[0] = token_origin;
            __lendees[0].username = transfer_destination;
            __lendees[0].token_status = true;
        }
        else{
            __lender = token_origin;
            __lender.username = transfer_destination;
            __lender.token_status = true;
            __lendees[0] = token_accepting;
            __lendees[0].username = accepting_party;
            __lendees[0].token_status = true;
        }    
        // TODO: write function which returns lender and lendee in this way from two tokens. 
        //user new_lender = retrieve_user_info(tran) 
        settle_contract(token_origin, token_accepting);
    }
    
    function settle_contract(stmt_token lender, stmt_token lendee) public{
        __lender = update_token_settlement(lender);
        // we settle contract only between two users. and we assume in this situation index 0 at array of lendees is the index of the 2nd person.
        __lendees[0] = update_token_settlement(lendee);
        // send signal with token info into our db to keep track about settled contracts
        // what information do we want to keep in this case?
        // balance/balance_string, date_in, date_out, username. id of users account nr. (we dont want to keep info about the number but rather if there are multiple accounts)
}

// correct the mistake with the ids of the lenders. because we're not holding the id of the person who ows/lend but the holder of the token. 

// in current situation 
// lender has its own token/
// lendee is in a list. [0] index is reserved for two sided opetarions. for situation of transfering tokens we can assume that the 
// accepting party is going to be in the [1] index.
}
